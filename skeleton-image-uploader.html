<link rel="import" href="../polymer/polymer-element.html">
<link rel="import" href="../polymer/lib/mixins/gesture-event-listeners.html">
<link rel="import" href="../paper-styles/color.html">
<link rel="import" href="../iron-image/iron-image.html">
<link rel="import" href="../iron-ajax/iron-ajax.html">
<link rel="import" href="./load-image.html">
<link rel="import" href="../polymerfire/firebase-storage-script.html">

<dom-module id="skeleton-image-uploader">
  <template>
    <style>
      :host {
        display: block;
        padding-bottom: 40%;
        position: relative;
      }

      #imageContainer {
        display: block;
        position: absolute;
        left: 0;
        right: 0;
        top: 0;
        height: 100%;
        z-index: 1;
        overflow: hidden;
      }

      :host([circle]) {
        padding-bottom: 100%;
      }

      :host([circle]) #imageContainer,
      :host([circle]) iron-image {
        border-radius: 50%;
      }

      iron-image {
        display: block;
        position: relative;
        cursor: pointer;
        z-index: 3;
        height: 100%;
        --iron-image-width: 100%;
        --iron-image-height: auto;
        --iron-image-placeholder: {
          background-color: var(--paper-grey-900);
        };
        /*@apply --image-styles;*/
      }

      paper-fab {
        position: absolute;
        z-index: 3;
        bottom: 0;
        right: 0;
        /*@apply --upload-icon-styles;*/
      }

      input {
        display: none;
      }
    </style>
    <iron-ajax id="vision"
               method="post"
               headers='{"content-type":"application/json","cache-control":"no-cache"}'
               handle-as="json"
               url$="https://vision.googleapis.com/v1/images:annotate?key=[[vision]]"
               on-response="_visionResponse"
               on-error="_visionError"
               debounce-duration="300"
               hidden
               disabled$="[[!vision]]"
    ></iron-ajax>
    <input id="media-capture"
           type="file"
           accept="image/jpeg,image/jpg"
           on-change="_initialize"
           hidden
           capture="user">
    <div id="imageContainer">
      <iron-image id="imagePreview" src$="{{imagePreview}}"
                  sizing="cover"
                  position="center"
                  preload
                  fade
                  on-tap="capture"
                  disabled$="{{uploading}}"
                  placeholder$="[[placeholder]]"></iron-image>
    </div>
  </template>

  <script>
    /* eslint-disable max-len */

    /**
     * `skeleton-image-uploader`
     *
     *
     * @customElement
     * @polymer
     * @demo demo/index.html
     */
    class SkeletonImageUploader extends Polymer.GestureEventListeners(Polymer.Element) {
      /**
       * @return {string}
       */
      static get is() {
        return 'skeleton-image-uploader';
      }

      /**
       * @return {Object}
       */
      static get properties() {
        return {
          path: {
            type: String,
            value: null,
          },
          imageDataUrl: {
            type: Object,
          },
          imageAnalysing: {
            type: Boolean,
            value: false,
          },
          uploading: {
            type: Boolean,
            value: false,
          },
          uploadProgress: {
            type: Number,
            reflectToAttribute: true,
            value: null,
          },
          imagePreview: {
            type: String,
            value: null,
          },
          imageVisionError: {
            type: Boolean,
            value: false,
          },
          imageSafe: {
            type: Boolean,
            value: true,
            // eslint-disable-next-line max-len
            computed: '_validateImages(imageVisionError, imageUnsafeAdult, imageUnsafeSpoof, imageUnsafeMedical, imageUnsafeViolence)',
          },
          imageUnsafeLogos: {
            type: Boolean,
            value: false,
          },
          imageUnsafeAdult: {
            type: Boolean,
            value: false,
          },
          imageUnsafeSpoof: {
            type: Boolean,
            value: false,
          },
          imageUnsafeMedical: {
            type: Boolean,
            value: false,
          },
          imageUnsafeViolence: {
            type: Boolean,
            value: false,
          },
          contentType: {
            type: String,
            value: 'image/jpeg',
          },
          metadata: {
            type: Object,
            value: {
              contentType: 'image/jpeg',
              customMetadata: {},
            },
          },
          finalMetadata: {
            type: Object,
            computed: '_computedMetadata(metadata, contentType)',
          },
          disabled: {
            type: Boolean,
            value: false,
          },
          vision: {
            type: String,
            value: null,
          },
          placeholder: {
            type: String,
            value: null,
          },
        };
      }

      /**
       * Start taking a picture.
       *
       * @private
       */
      capture() {
        this.shadowRoot.querySelector('input').click();
      }

      /**
       * Initialize the image capture
       *
       * @param {object} event
       * @private
       */
      _initialize(event) {
        this._resetImageProperties();
        const image = this.shadowRoot.querySelector('#media-capture').files[0];
        this._setImagePreview(image);
      }

      /**
       * Upload a single image
       *
       * @param {string} image
       * @param {string} location
       * @private
       */
      _uploadImage(image, location) {
        // create a storage reference
        const storage = firebase.storage().ref(location);
        // Upload the file
        const uploadTask = storage.put(image, this.finalMetadata);
        uploadTask.on('state_changed', (snapshot) => {
          // Observe state change events such as progress, pause, and resume
          const progress = (snapshot.bytesTransferred / snapshot.totalBytes) * 100;
          this.uploadProgress = progress;
          switch (snapshot.state) {
            case firebase.storage.TaskState.PAUSED: // or 'paused'
              console.log('Upload is paused');
              break;
            case firebase.storage.TaskState.RUNNING: // or 'running'
              console.log('Upload is running');
              break;
          }
        }, (error) => {
          // Handle unsuccessful uploads
        }, () => {
          // Handle successful uploads on complete
          // For instance, get the download URL: https://firebasestorage.googleapis.com/...
          let downloadURL = uploadTask.snapshot.downloadURL;
          console.log(downloadURL);
        });
      }

      /**
       * set image preview
       *
       * @param {string} imageObject
       * @private
       */
      _setImagePreview(imageObject) {
        loadImage(
          imageObject,
          (img) => {
            const finalImage = img.toDataURL('image/jpeg');
            this.imagePreview = finalImage;
            if (!this.vision) return this._createImage();
            this._vision(finalImage);
          }, {
            maxWidth: 1000,
            maxHeight: 1000,
            minWidth: 600,
            minHeight: 600,
            canvas: true,
          }
        );
      }

      /**
       * set image preview
       *
       * @private
       */
      _createImage() {
        const imageObject = this.shadowRoot.querySelector('#media-capture');
        const imageRoute = imageObject.files[0];
        if (!imageRoute) return;

        loadImage(
          imageRoute,
          (data) => {
            const image = this._toBlob(data);
            this._uploadImage(image, this.path);
          }, {
            maxWidth: 2500,
            maxHeight: 2500,
            minWidth: 300,
            minHeight: 300,
            canvas: true,
            crop: false,
            meta: true,
          }
        );
      }

      /**
       * Blob the image to be able to upload
       *
       * @param {object} canvas
       * @param {string} type
       * @param {number} quality
       * @return {*}
       * @private
       */
      _toBlob(canvas, type = 'image/jpeg', quality = 0.9) {
        const binStr = atob(canvas.toDataURL(type, quality).split(',')[1]);
        const len = binStr.length;
        const arr = new Uint8Array(len);
        for (let i = 0; i < len; i++) {
          arr[i] = binStr.charCodeAt(i);
        }
        return new Blob([arr], {
          type: type || 'image/jpeg',
        });
      }

      /**
       * Clear uploader
       *
       * @private
       */
      _clearUpload() {
        this.uploading = false;
        this.uploadProgress = 0;
      }

      /**
       * Reset the image properties
       *
       * @private
       */
      _resetImageProperties() {
        this.imageAnalysing = true;
        this.imageVisionError = false;
        this.imageUnsafeLogos = false;
        this.imageUnsafeAdult = false;
        this.imageUnsafeSpoof = false;
        this.imageUnsafeMedical = false;
        this.imageUnsafeViolence = false;
      }

      /**
       * Call vision to validate and prepare the image
       *
       * @param {string} image
       * @private
       */
      _vision(image) {
        // Reformat image
        const finalImage = image.replace(/^data:image\/[a-z]+;base64,/, '');
        this._visionFormat(finalImage);
      }

      /**
       * Set the json object for the Google Cloud Vision Request
       *
       * @param {string} image
       * @private
       */
      _visionFormat(image) {
        const data = JSON.stringify({
          'requests': [{
            'image': {
              'content': image,
            },
            'features': [{
              'type': 'SAFE_SEARCH_DETECTION',
              'maxResults': 1,
            }],
          }],
        });
        this._sendVisionRequest(data);
      }

      /**
       * Send request to Google Cloud Vision
       *
       * @param {object} bodyData
       * @private
       */
      _sendVisionRequest(bodyData) {
        const vision = this.shadowRoot.querySelector('#vision');
        vision.body = bodyData;
        vision.generateRequest();
      }

      /**
       * Parse the response from Google Cloud Vision
       *
       * @param {object} response
       * @private
       */
      _visionResponse(response) {
        let responses = response.detail.response.responses[0];
        if (responses) {
          const safeSearchAnnotation = responses.safeSearchAnnotation;
          if (safeSearchAnnotation) {
            this._validateSafeImage(safeSearchAnnotation);
          }
        }
        this.imageAnalysing = false;
      }

      /**
       * Validate the image and check if is safe to upload.
       * @param {object} safeSearchAnnotation
       * @private
       */
      _validateSafeImage(safeSearchAnnotation) {
        const isAdult = this._checkSafe(safeSearchAnnotation.adult);
        const isSpoof = this._checkSafe(safeSearchAnnotation.spoof);
        const isMedical = this._checkSafe(safeSearchAnnotation.medical);
        const isViolence = this._checkSafe(safeSearchAnnotation.violence);
        if (isAdult) {
          this.imageUnsafeAdult = true;
        }
        if (isSpoof) {
          this.imageUnsafeSpoof = true;
        }
        if (isMedical) {
          this.imageUnsafeMedical = true;
        }
        if (isViolence) {
          this.imageUnsafeViolence = true;
        }
        if (!isAdult && !isSpoof && !isMedical && !isViolence) {
          this._createImage();
        } else {
          console.error('Image is unsafe');
        }
      }

      /**
       * Handle error from Google Cloud Vision
       * @private
       * @param {object} error
       */
      _visionError(error) {
        console.error('vision', error);
        this.imageVisionError = true;
      }

      /**
       * @param {object} Likelihood
       * @return {boolean}
       * @private
       */
      _checkSafe(Likelihood) {
        const unsafeImages = ['UNKNOWN', 'POSSIBLE', 'LIKELY', 'VERY_LIKELY'];
        let i = unsafeImages.length;
        while (i--) {
          if (Likelihood === unsafeImages[i]) {
            return true;
          }
        }
        return false;
      }

      /**
       * Validate the post fields and the images
       *
       * @param {boolean} visionError
       * @param {boolean} adult
       * @param {boolean} spoof
       * @param {boolean} medical
       * @param {boolean} violence
       * @return {boolean}
       * @private
       */
      _validateImages(visionError, adult, spoof, medical, violence) {
        return !visionError && !adult && !spoof && !medical && !violence;
      }

      /**
       * Compute metadata
       * @param {object} metadata
       * @param {string} contentType
       * @return {*}
       * @private
       */
      _computedMetadata(metadata, contentType) {
        if (!metadata) {
          return {
            contentType: 'image/jpeg',
            customMetadata: {},
          };
        }
        let fileMetadata = {};
        fileMetadata = metadata;
        fileMetadata.contentType = contentType;
        return fileMetadata;
      }
    }

    window.customElements.define(SkeletonImageUploader.is, SkeletonImageUploader);

  </script>
</dom-module>
